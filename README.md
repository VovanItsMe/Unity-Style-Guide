# Unity Style Guide

Эта статья содержит то, какая структура, нейминг для скриптов и ассетов должны использоваться в структуре проекта Unity. 

<a name="toc"></a>
## Содержание

> 1. [Вступление](#introduction)
> 1. [Структура Проекта](#structure)
> 1. [Скрипты](#scripts)
> 1. [Правила Нейминга Ассетов И Назначение Лейблов](#anc)
> 1. [Asset Workflows](#asset-workflows)

<a name="introduction"></a>
## 1. Вступление

### Разделы

> 1.1 [Стиль](#style)

> 1.2 [Базовая Терминология](#importantterminology)

<a name="style"></a>
### 1.1 Стиль

#### Если у вашей команды существует стайл гайд, вы должны ему следовать.
Если Вы работаете над проектом, в команде, которая следует стайл гайду, Вы также должны ему следовать. Все несоответствия между вашим стилем и прописанным в гайде не должны существовать.

Стайл гайд не является константой - он может быть изменён, при наличии непрописанных ситуаций, если это действительно необходимо.

> ##### *Споры о стиле бессмысленны. Существует стайл гайд, и ты обязан ему следовать.*
> [_Rebecca Murphey_](https://rmurphey.com)

#### Вся структура, ассеты и код, должны выглядеть так, будто их создал один человек. Не важно сколько людей работали над ними.
При переходе с одного проекта на другой, не должно быть различий в стиле и структуре.

Соблюдение единого стиля устраняет хаос в структуре проекта.

Общий стиль позволяет без проблем поддерживать проект, не нужно думать о его новой структуре, просто следуй инструкциям. Этот стайл гайд написан с учётом всех известных проблем, так что, если они возникнут, их будет проще отследить.

#### Друзья, не позволяйте вашим друзьям вносить беспорядок в проект.
Если Вы видите, что кто-то не следует стилю - поправьте их.

При работе в команде, заметно легче помочь и попросить о помощи, когда люди объединены. Никому не нравится искать проблему там, где он видит только беспорядок.

Если вы помогаете человеку, который следует, пусть и другому, но стилю - вам проще приспособиться к нему. Если же стиля нет - посоветуйте ему сначала поработать над ним.


<a name="importantterminology"></a>
### 1.2 Базовая Терминология

<a name="terms-prefab"></a>
#### Префабы
Unity использует термин “Префаб” (“Prefab”) для системы, которая позволяет создавать, настраивать, и хранить “Игровой Объект” (“GameObject”), вместе со всеми компонентами, конкретными значениями, и дочерними “Игровыми Объектами”, как многоразового ассета, представляя, своего рода, контейнер.

<a name="terms-label"></a>
#### Лейблы
Лейблы (“Label”) используются для упрощения поиска, однако давать лейбл нужно только префабам, потому как у них нет префикса.

<a name="terms-level-map"></a>
#### Уровни/Карты/Сцены
В Unity существуют сцены, однако часто люди называют их уровнями или же картами. Простыми словами - сцены содержат в себе множества объектов.

<a name="terms-serializable"></a>
#### Serializable
Переменные, которые Serializable показываются в окне “Инспектора” (“Inspector”) в Unity. Больше информации вы найдёте в документации к Unity, в статье [Serializable](https://docs.unity3d.com/Manual/script-Serialization.html).

<a name="terms-cases"></a>
#### Cases
Существует несколько вариантов того, как вы можете называть вещи. Вот несколько примеров:

> ##### PascalCase
> Каждое слово пишется с заглавной буквы, без пробелов: `DesertEagle`, `StyleGuide`, `ASeriesOfWords`.
> 
> ##### camelCase
> Каждое слово пишется с заглавной буквой, но первое слово начинается с прописной: `desertEagle`, `styleGuide`, `aSeriesOfWords`.
>  ##### lowercase
> Все буквы прописные - `deserteagle`, 
>
> ##### Snake_case
> Слова могут начинаться как с заглавной, так и с прописной, однако слова разделяет нижнее подчёркивание: `desert_Eagle`, `Style_Guide`, `a_Series_of_Words`.

**[⬆ Вверх](#table-of-contents)**

<a name="structure"></a>
## 2. Структура Проекта
Стиль структуры проекта должен считаться законом. Нейминг ассетов и папок должны соответствовать друг другу, несоответствие хотя бы одного элемента может привести к беспорядку “на ровном месте”.

Данный стиль и структура оптимизированы как для простого перемещения между папок, так и для поиска в окне “Проекта” (“Project”), подобный формат имеет преимущества над стилями, использующими иную структуру и нейминг.

> Использование префикса [правил нейминга](#asset-name-modifiers), хранение в папках однотипных ассетов как: `Меши`, `Текстуры`, и `Материалы` – является излишним поскольку типы ассетов уже отсортированы по префиксу и могут быть отфильтрованы в поиске.
<pre>
	Структура проекта должна выглядеть подобным образом:
Assets
    _Developers (Использование `_` помещает файл вверх)
        DeveloperName (Личная папка разработчика, в ней содержатся тестовые ассеты, которые не попадут в финальный проект и будут удалены при мёрдже)
    ProjectName (Основная папка проекта)
	
            	Objects (Содержит модели с текстурами и материалами, бесшовные текстуры с материалами, анимационные контроллеры и анимационные клипы, карты высот для построения террейнов, оптимизированные и финализированные составные элементы отдельных карт)
                	Environment 
(Содержит модели с текстурами и материалами)

				Architecture (Содержит большие постройки)
					Buildings (Содержит здания)
						House
							Materials
							Textures
				Common (Содержит модели окружения)
					Big 
			(Большие, по типу: бочек, заборов, фонарей и тп.)

					Small 
			(Маленькие, по типу: коробок, мусорных пакетов и тп.)

				Ground (Содержит файлы разметки, трещин и тп.)
	
				Industrial (Содержит большие модели окружения, относящиеся к индустриализации, по типу: портовые и строительные краны, большие цистерны с топливом, электроопоры, вышки, морские контейнеры и тп.)

				Military (Содержит модели, относящиеся к оборонительным сооружениям, военной технике и тп.)

				Nature (Содержит объекты природного происхождения, по типу: травы, деревьев, кустов, камней и тп.)

				Transport (Содержит транспорт)
					Aircraft (Воздушный)
					Cars (Наземный)
					Ships (Водный)
			Gameplay 
(Содержит объекты для геймплея)

				Maps (Содержит оптимизированные и финализированные составные элементы отдельных карт)
					City
			General
				Animations (Содержит анимационные клипы с анимационными контроллерами, как общие, так и для конкретных объектов)

				MapHeightmaps 
(Содержит карты высот для построения террейнов)

				SeamlessMaterials 
(Содержит бесшовные материалы с их текстурами)

		Prefabs 
(Содержит файлы префабов, та же иерархия папок, как и в папках объектов)

			CompositionPrefabs (Содержит трафареты для построения шаблонных локаций и сборные композиции, часто применяемые на сценах)

				Architecture
				Common
				Ground
				Industrial
				Military
				Nature
				Transport
			Environment (Содержит отдельные и собранные префабы)
				Architecture
				Common
				Ground
				Industrial
					Container (Отдельные префабы)
						Complete (Собранные префабы)
				Military
				Nature
				Transport
			Gameplay 
(Содержит объекты префабов, необходимые для работы игры)
	
		Scenes 
(Содержит сцены и файлы для их настройки, к примеру - профили постобработки)
			BootScene (Сцена запуска и файлы к ней)
			GameMaps (Игровые сцены и файлы к ним)
				City
            Scripts

            Sound

            UI (Содержит файлы элементов интерфейса и файлы для его работы)
		Fonts (Файлы шрифтов)
		Image ()
		Materials ()
		Prefabs ()
		Scripts ()
    Plugins (Содержит сторонние пакеты, аддоны)
</pre>

Причины использования данной структуры описаны ниже, в подразделах.

### Подразделы

> 2.1 [Названия Папок](#structure-folder-names)

> 2.2 [Корневая Папка](#structure-top-level)

> 2.3 [Личные Папки Разработчиков](#structure-developers)

> 2.4 [Сцены](#levels)

> 2.5 [Разделение Ответственности](#structure-ownership)

> 2.6 [`Assets` или `AssetTypes`](#structure-assettypes)

> 2.7 [Большие Композиции Должны Иметь Свои Папки](#structure-large-sets)

> 2.8 [Библиотека Материалов](#structure-material-library)

> 2.9 [Структура Сцены](#scene-structure)


<a name="2.1"></a>
<a name="structure-folder-names"><a>
### 2.1 Наименования папок
Базовые правила наименования папок в структуре проекта.

<a name="2.1.1"></a>
#### Обязательный стиль названия - [PascalCase](#terms-cases)
PascalCase значит, что слова начинаются с заглавной буквы и не имеют пробела между друг другом. Пример: `DesertEagle`, `RocketPistol` и `ASeriesOfWords`.

<a name="2.1.2"></a>
#### Никогда Не Используй Пробелы
Дополнение [2.1.1](#2.1.1), никогда не используй пробелы. Пробелы могут создавать проблемы для различных инструментов и процессов. В идеале путь к вашему проекту на компьютере должен выглядеть так `“D:\Project”`, вместо `“C:\Users\My Name\My Documents\Unity Projects”`.

<a name="2.1.3"></a>
#### Никогда Не Используй Специальные Символы И Знаки Unicode
примеру, в вашем проекте имеется персонаж с именем 'Zoë', значит его файл должен называться “Zoe”. Символы Unicode могут создать даже больше проблем чем [Пробелы](#2.1.2) потому как для некоторых инструментов и частей программ могут не поддерживаться символы Unicode в пути к файлам.

К слову, если имя пользователя на вашем пк содержит символы Unicode (т.е. имя пользователя `“Zoë”`), любой проект, находящийся в папке `“My Documents”` будет страдать от этой проблемы. Обычно перемещение в корневую папку диска, к примеру `“D:\Project”` может исправить связанные с этим проблемы.

Использование спец. символов по типу: `a-z`, `A-Z`, и `0-9` а также `@, -, _, ,, *`, и `#` таким же образом может повлечь за собой: труднодиагностируемые проблемы на других платформах, контроль версий, некорректную работу различных инструментов и тд.

<a name="structure-no-empty-folders"></a>
#### НЕТ Пустым Папкам
В проекте не должно быть пустых папок. Они мешают при поиске.
Если же вы нашли пустую папку, нельзя просто так взять и удалить её, сначала нужно убедиться в следующем:
1.	Убедитесь, что вы на актуальной версии ветки.
2.	Спросите у своих коллег, необходима ли им эта папка.
3.	Откройте папку через проводник для проверки скрытых файлов и удалите их.
4.	Перейдите в проект и убедитесь, что его работа не нарушена.
5.	Убедитесь, что папка удалена.
6.	Закоммитьте внесённые изменения.

<a name="2.2"></a>
<a name="structure-top-level"><a>
### 2.2 Используйте Корневую Папку Только Для Особых Ассетов
Все ассеты проекта должны находиться в папках, находящихся внутри папки с названием проекта. К примеру, ваш проект называется 'Generic Shooter', всё его содержимое находится по пути “Assets/GenericShooter”.

Папка “Developers” нужна, для вашей личной папки, в которой могут содержаться ваши файлы, для, например, тестирования. Смотрите [Папки Разработчиков](#2.3) для более детальной информации.

Существует множество причин, по которым необходима такая структура.

<a name="2.2.1"></a>
#### НЕТ Глобальным Ассетам
Довольно часто в код стайл гайдах написано, что не следует использовать без особых причин глобальные пространства имён, ровно по тем же причинам. В случае, когда ассеты находятся в корневой папке, они не следуют общему стилю, а это обязательно приводит к хаосу, потому как нет нужды распределять ассеты должным образом.

У каждого ассета должно быть своё предназначение, иначе он не должен находиться в проекте. Если ассет предназначен для тестирования и не будет, в дальнейшем, использован с проекте, он должен находиться в вашей личной папке, в папке [Developers](#2.3).

<a name="2.2.2"></a>
#### Уменьшить Конфликты При Переиспользовании
При работе над несколькими проектами, копирование различных ассетов из одного проекта в другой – обычное дело.

Все ассеты, даже испортные, должны быть размещены согласно [Структуре Проекта](#structure).

Во избежание проблем с увеличением веса проекта, при добавлении пакета ассетов, хорошей практикой будет сохранение только необходимых ассетов для текущего проекта. Также необходимо занести все ассеты импортного пакета в базу.

<a name="2.2.2e1"></a>
##### Пример Основного Материала
Скажем, Вы создали материал, который хотите использовать в нескольких проектах сразу, вот, Вы скопировали его в другой проект. Можете не помещать его в корневую папку, если путь к нему выглядит так `“Assets/MaterialLibrary/M_Master”`. При условии, что в проекте, в который происходит перенос, не существует материала с таким названием. В этом случае проблемы не возникнут.

В процессе работы, скопированные материалы могут изменяться под нужды конкретного проекта.

Однако проблемы могут возникнуть, когда необходимо будет перенести КОМПОЗИЦИЮ, состоящую из разных ассетов, в другой проект, при этом она будет использовать основной материал, к примеру, расположенный по пути `“Assets/MaterialLibrary/M_Master”`, если, как в случае, описанном выше, у нас находится по этому же пути изменённый материал, тогда в ассетах композиции будет использован изменённый материал, это и приведёт к дальнейшим проблемам.

Подобную проблему трудно предсказать и бывает трудно заметить, потому что тот, кто перемещает КОМПОЗИЦИЮ может быть не тем, кто её составлял и не знать, что они используют основной материал по тому же пути. The Migrate tool требуется вся цепочка зависимых ассетов, в свою очередь это требует перемещения материала по пути `"Assets/MaterialLibrary/M_Master"` при копировании, может получиться так, что он заменит существующие файлы проекта теми, которые он переносит.

В случае, если скопированные материалы изменились, вы рискуете столкнуться с проблемами, в виде нарушения зависимостей ассетов, расположенных по тому же пути, что и в оригинальном проекте, из-за того, что перенесённые ассеты были распределены по всему проекту, вместо нахождения в отведённой для этого папки. Таким образом, казалось бы, банальное перемещение ПРЕФАБОВ моделей может стать очень проблемным занятием.

<a name="2.2.3"></a>
#### Тестовые Файлы, Шаблоны, и Сторонние Ассеты Безопасны
Дополнение к [2.2.2](#2.2.2), если член команды добавил тестовые файлы, файлы шаблонов или сторонние ассеты, в большинстве случаев они не нарушат работу проекта, но только в случае, если имя корневой папки не было изменено.

Однако необязательно, чтобы сторонние ассеты следовали [правилу корневой папки](#2.2). Существует множество пакетов, большинство файлов которых расположено в корневой папке, но также возможно без проблем перенести их в основную папку проекта для освобождения корневой.

При соблюдении [2.2](#2.2), худший конфликт сторонних ассетов - если несколько пакетов имеют одинаковые тестовые файлы. Если все ваши ассеты находятся в папке проекта, включая тестовые файлы, их следует переместить в вашу папку в _Developers, такой подход поможет избежать подобных конфликтов.

#### Дополнения, Подпроекты, и Патчи Легко Поддерживать
Если предполагается разработка дополнений (DLC) к вашему проекту, или же с ним связано множество подпроектов которые будут перенесены или просто не добавлено в билд, относящиеся к ним ассеты должны находиться в корневой папке.
Подобное отделение DLC значительно упрощает работу над проектом. Подпроекты также могут добавляться и удаляться без особых усилий.

Если вам нужно изменить материал ассета или добавить какой-либо ассет, заменяющий другой, в патче, вы можете просто добавить его в папку для патча и продолжить работу, зная, что основной проект не повредится.

<a name="2.3"></a>
<a name="structure-developers"></a>
### 2.3 Используй Папку Разработчика Для Тестирования
При разработке проекта, очень часто членам команды нужна тестовая площадка, которая не повредит основной проект.
Поскольку работа ведётся непрерывно, эти разработчики могут захотеть запушить свои изменения. Не везде есть правило, что нужно использовать папку разработчика, однако без неё есть шанс получить конфликт при работе с гитом.

Как только работа над файлами будет завершена – разработчик просто переместит их в папку основного проекта.

После окончания работы над своей веткой и мёржде в develop, все данные из личной папки данного разработчика в папке _Developers должны быть удалены самим разработчиком, либо ревьюиром.

<a name="levels"></a>
### 2.4 Все Файлы для [Сцены](#terms-level-map) Должны Находиться в Папке “Уровни”
Файлы для уровней особенные и обычно для них в каждом проекте существует своя система нейминга, особенно, если идёт работа над подпроектами или `streaming levels`. Не имеет значения, какая система структуризации карт для каждого проекта, все уровни должны находиться по пути `"Assets/ProjectNameName/Levels"`.

Возможность сказать кому-то открыть конкретную карту, без объяснения где она находится может сэкономить много времени, а также повысить “качество жизни”. Обычно для каждого уровня существуют подпапки в папке `"Levels"`, например `"Levels/Campaign1/"` или `"Levels/Arenas"`, но самая важное то, что все они находятся в единой папке `"Assets/ProjectNameName/Levels"`.

Это также способствует облегчению билда для инженеров. Поиск сцен может затянуться, если искать их по всему проекту. Если же все сцены находятся в одной папке “потерять” их при билде становится трудно. Это так же упрощает сборку освещения и QA processes.

<a name="2.5"></a>
<a name="structure-ownership"></a>
### 2.5 Разделение Ответственности
В командах, где больше одного разработчика, стоит разделять ответственность по зонам/ассетам/функционалу. Некоторые ассеты вроде сцен и префабов не могут адекватно обработать изменения от нескольких людей, создавая конфликты.
В таких случаях стоит назначить одного человека (или дать право на изменения), что позволит избежать подобных конфликтов.

<a name="2.6"></a>
<a name="structure-assettypes"></a>
### 2.6 Не Создавать Папки С Названием `Assets` или `AssetTypes`

<a name="2.6.1"></a>
#### Создание папки Assets излишне.
Все ассеты - ассеты.

<a name="2.6.2"></a>
#### Creating a folder named `Meshes`, `Textures`, or `Materials` is redundant.
`All asset names are named with their asset type in mind. These folders offer only redundant information and the use of these folders can easily be replaced with the robust and easy to use filtering system the Content Browser provides.`

`Want to view only static mesh in `Environment/Rocks/`? Simply turn on the Static Mesh filter. If all assets are named correctly, they will also be sorted in alphabetical order regardless of prefixes. Want to view both static meshes and skeletal meshes? Simply turn on both filters. this eliminates the need to potentially have to `Control-Click` select two folders in the Content Browser's tree view.`

> `This also extends the full path name of an asset for very little benefit. The `SM_` prefix for a static mesh is only three characters, whereas `Meshes/` is seven characters.`

`Not doing this also prevents the inevitability of someone putting a static mesh or a texture in a `Materials` folder`.

<a name="2.7"></a>
<a name="structure-large-sets"></a>
### 2.7 Большие Композиции Должны Иметь Свои Папки

Это можно расценивать как псевдо-исключение из [2.6](#2.6).

Существует несколько типов ассетов, которые объединяют огромное количество файлов, при этом имея уникальное применение. Обычно это звуковые файлы и файлы анимации. Если в вашем проекте количество связанных файлов 15 и более, они должны быть вместе.

Например, анимационные клипы для нескольких персонажей должны находиться в `"Characters/Common/Animations"`, также могут быть подпапки Locomotion или Cinematic.

Это не применимо к таким файлам как текстуры и материалы. К примеру, папка Rocks содержит множество текстур при большом количестве моделей камней, однако разные текстуры принадлежат разным камням и должны иметь соответствующее название. Даже если эти текстуры находятся в [Библиотеке Материалов](#2.8).

<a name="2.8"></a>
<a name="structure-material-library"></a>
### 2.8 `Библиотека Материалов`

Если в вашем проекте используются общие материалы, layered materials, или иные формы переиспользуемых материалов и текстур которые не принадлежат конкретным ассетам, они должны находиться в `"Assets/ProjectName/MaterialLibrary"`.

Таким образом “глобальные” материалы будут иметь своё место, в котором их легко найти.
Это также позволяет легко следовать указанию 'use material instances only' в проекте. Если все должны использовать material instances, тогда только обычные материалы должны находиться в этой папке. Вы можете легко отследить это искав только base материалы, не расположенные в `MaterialLibrary`.

`MaterialLibrary` не обязана содержать исключительно материалы. Shared utility textures, material functions, и другие файлы подобного назначения должны находиться в папках, отражающих их назначение. Например, generic noise textures должны находиться в `"MaterialLibrary/Utility"`.

Все тестовые материалы или материалы для дебага должны находиться в `"MaterialLibrary/Debug"`. Это позволяет быстро вырезать материалы для дебага из проекта перед переносом и делает ошибки более очевидными, если ассеты проекта используют их.

<a name="2.9"></a>
<a name="scene-structure"></a>
## 2.9 Структура Сцены
Уходя от иерархии проекта, переходим к иерархии сцены. Как и раньше, это лишь шаблон. Вы можете подстроить его под свои нужды.

Используйте Пустые Объекты (Create Empty) как папки на сцене.

<pre>
Debug
Management
UI
Cameras
Lights
World
    Terrain
    Props
Gameplay
	Actors
	Items
_Dynamic
</pre>

-	У всех родительских объектов (пустых), должны быть координаты 0,0,0 со стандартными скейлом и вращением.
-	Для пустых объектов, которые являются объектами для скриптов, используйте “@” как префикс – “@Cheats”
-	Когда вы инициализируете объекты в runtime, убедитесь, что они находятся в _Dynamic – не забивайте основную иерархию, в противном случае вам будет трудно ориентироваться в ней.


**[⬆ Вверх](#table-of-contents)**

<a name="scripts"></a>

## 3. Скрипты

Этот раздел будет сфокусирован на классах C# и их содержимом. Если это возможно, соблюдайте стиль, соответствующий стандартам Microsoft C#.

### Sections
> 3.1 [Организация Классов](#classorganization)

> 3.2 [Компиляция](#compiling)

> 3.3 [Переменные](#variables)

> 3.4 [Функции](#functions)

<a name="classorganization"></a>
### 3.1 Организация Классов
Файлы скриптов должны содержать только публичные типы, однако допустимы подклассы.

Source файлы должны именоваться также как публичный класс.

Делайте организацию пространства имён с чёткой структурой,

Группы классов должны быть расположены в алфавитном порядке и сгруппированы по секторам:

* Constant Fields
* Static Fields
* Fields
* Constructors
* Properties
* Events / Delegates
* LifeCycle Methods (Awake, OnEnable, OnDisable, OnDestroy)
* Public Methods
* Private Methods
* Nested types
* Debug

Каждая из этих групп отсортирована по модификаторам доступа:
* public
* internal
* protected
* private
```
namespace ProjectName
{
	/// <summary>  
	/// Краткое описание того, что делает класс
	/// </summary>
    public class Account
    {
      #region Fields
      
      [Tooltip("Публичные переменные устанавливаемые в Инспекторе, должны иметь Подсказку")]
      public static string BankName;
      
	  /// <summary>  
	  /// Они также должны иметь описание
	  /// </summary>
      public static decimal Reserves;
 
	  public string BankName;
	  public const string ShippingType = "DropShip";
	  
	  private float _timeToDie;
	  
	  #endregion
	  
	  #region Properties
	  
      public string Number {get; set;}
      public DateTime DateOpened {get; set;}
      public DateTime DateClosed {get; set;}
      public decimal Balance {get; set;}
            
	  #endregion
	 
	  #region LifeCycle
	  
      public Awake()
      {
        // ...
      }
      
      #endregion
	  #region Public Methods
	  
      public AddObjectToBank()
      {
        // ...
      }
      
      #endregion
    }
}
```

#### Шаблоны Скриптов
Чтобы сэкономить немного времени можно переписать стандартный шаблон скриптов Unity своим собственным, для автоматической настройки пространств имён, регионов и тп. Изучите как это сделать в Unity [support](https://support.unity3d.com/hc/en-us/articles/210223733-How-to-customize-Unity-script-templates).

<a name="namespace"></a>
#### Namespace
Используйте namespace чтобы убедиться, что обзор classes/enum/interface/etc не будет вступать в конфликты с существующими namespaces или global namespace.
В проекте должно использоваться минимальное количество the projects name для Namespace чтобы избежать конфликтов со сторонними ассетами.

#### Все Публичные Функции Должны Иметь Описание

Всё просто – любая функция, имеющая модификатор доступа Public должна иметь описание.

```
/// <summary>
/// Стрельба из пистолета
/// </summary>
public void Fire()
{
// Выстрел из пистолета.
}
```

#### Foldout Groups
Если класс содержит небольшое количество переменных, Foldout Groups не обязательны.

При условии, что класс содержит много (5-10) переменных, все [Serializable](#serializable) переменные должны иметь нестандартные применённые Foldout Group. Обычно они относятся к категории `Config`.

Для того, чтобы создать Foldout Groups существует 2 способа в Unity. 

* Первый - это определить `[Serializable] public Class` внутри главного класса, однако это может повлиять на производительность. Это позволит многократно использовать одно имя для переменной.
* Второй вариант – это использовать Foldout Group Attribute доступный в [Odin Inspector](https://odininspector.com/).

```
[[Serializable](https://docs.unity3d.com/ScriptReference/Serializable.html)]
public struct PlayerStats
	{
        public int MovementSpeed;
    }
    
[FoldoutGroup("Interactable")]
public int MovementSpeed = 1;
```

#### Комментирование
Комментарии должны описывать intention, algorithmic overview, и/или logical flow.

В идеале, читая комментарии, любой должен понять, за что отвечает скрипт, а не только тот, кто его разрабатывал.

Нет установленной длины комментария, очевидные и короткие методы не обязательно должны иметь комментарии, однако подавляющее большинство методов должно их иметь, чтобы отражать подход и намерения программиста.

##### Стиль комментариев
Располагайте комментарии на отдельных строках, а не в конце строки после кода.

Пишите комментарии начиная с заглавной буквы.

В конце комментария ставится точка.

Ставьте пробел после (//) в тексте, как показано в примере.

Подобный стиль комментария - // (две косые черты), должен использоваться в большинстве ситуаций. Где возможно – оставляйте комментарии над кодом, а не возле него.

Пример:

```
        // Простой комментарий над переменной.
        private int _myInt = 5;
```

#### Регионы
Регионы `“#region”` позволяют сворачивать отмеченные ими части кода в скриптах C#. Возможность сворачивать части кода выборочно делает его удобнее и читаемее.

Пример:

```
#region "This is the code to be collapsed"
    Private components As System.ComponentModel.Container
#endregion
```

#### Промежутки
Ставьте пробел после запятой, при перечислении аргументов.

Example: `Console.In.Read(myChar, 0, 1);`
* Не ставьте пробел после скобок и аргументов функции.
* Не ставьте пробел между названием функции и скобкой.
* Не ставьте пробел в скобках (квадратных). 

<a name="3.1"></a>
<a name="compiling"></a>
### 3.2 Компиляция
Все скрипты должны быть скомпилированы без предупреждений и ошибок. При возникновении подобных, их необходимо скорее исправить, потому как могут возыметь непредвиденные и серьёзные последствия.

*Ни в коем случае* **нельзя** пушить скрипты с ошибками.

### 3.3 Переменные
Слова `переменная` и `свойство` для вас должны означать одно и то же и быть взаимозаменяемыми. 

#### Названия Переменных

##### Nouns
Все небулевые переменные должны быть понятным, однозначными и быть существительными.

##### Case
Все переменные должны использовать PascalCase, кроме [private](#privatevariables), использующие camelCase. 

Используй PascalCase для аббревиатур из 4-х или более букв (из 3-х символов 2 заглавные).

##### Considered Context
Все переменные должны иметь название, сопоставимое с их предназначением.

###### Примеры Considered Context:
Возьмём класс `PlayerCharacter`.

**Плохо**

* `PlayerScore`
* `PlayerKills`
* `MyTargetPlayer`
* `MyCharacterName`
* `CharacterSkills`
* `ChosenCharacterSkin`

Все переменные имеют излишне длинное название. Подразумевается, что они относятся к классу `PlayerCharacter`, однако класс, в котором они находятся и есть `PlayerCharacter`.

**Хорошо**

* `Score`
* `Kills`
* `TargetPlayer`
* `Name`
* `Skills`
* `Skin`

#### Уровень Доступа к Переменным
В C# у переменных есть модификатор доступа.

Public означает, что к данной переменной можно получить доступ вне скрипта (или класса).

Protected означает, что только дочерние классы и сам класс имеет доступ к переменной.

Private означает, что переменная доступна исключительно для этого класса.

Переменные должны быть публичными **только в случае необходимости**.

Лучше использовать `[SerializeField]`, вместо обозначения её Public.

##### Локальные Переменные
Локальные переменные должны именоваться по camelCase.

###### Неявное Типизирование Локальных Переменных
Используйте скрытые типы для локальных переменных если тип переменной явно виден из её значения по правую сторону равенства, или когда точный тип не важен.

```
var var1 = "Очевидно, это string.";
var var2 = 27;
var var3 = Convert.ToInt32(Console.ReadLine());
// Also used in for loops
for (var i = 0; i < bountyHunterFleets.Length; ++i) {};
```

Не используйте var, если тип не очевиден из значения переменной.
Пример:

```
int var4 = ExampleClass.ResultSoFar();
```

<a name="privatevariables"></a>
##### Приватные Переменные
Приватные переменные должны иметь префикс с нижним подчёркиванием “_myVariable“ и использовать camelCase.

Не помечайте переменную как Private, если не известно, должен ли дочерний класс иметь к ней доступ. До этого времени используйте `protected`, определяя Private, когда будет известно, что дочерний класс не должен иметь к ней доступ.

##### Do _Not_ use Hungarian notation
Do _not_ use Hungarian notation или иной вид идентификаторов в идентификаторах
```
// Правильно
int counter;
string name;
 
// Неправильно
int iCounter;
string strName;
```

#### Переменные доступные в Editor

##### Tooltips 
Все [Serializable](#serializable) переменные должны иметь поля подсказок `[Tooltip]`, которые описывают, какие изменения повлечёт за собой изменение значения переменной.

##### Variable Slider And Value Ranges
Все [Serializable](#serializable) переменные, должны использовать ползунок с ограниченными значениями, для того, чтобы было *невозможно* установить некорректное значение переменной.

Пример: Скрипт, отвечающий за генерацию секций забора должен иметь изменяемую переменную `PostsCount`, значение которой равное или меньше -1 не должно быть доступным. Используйте диапазон значений `[Range(min, max)]`, с отметкой 0, как минимальное.

Если изменяемая переменная используется в Construction Script, диапазон значений должен быть установлен таким образом, чтобы выставление значений не повлекло за собой краш эдитора.

Диапазон значений также необходим для обозначения допустимых пределов переменной. Если установленный диапазон значений помогает задавать “адекватное” значение переменной, то неустановленный диапазон значений позволяет пользователю выставлять “неадекватные” значения, которые, однако, необязательно создадут проблемы.

#### Типы Переменных

##### Булевые

###### Булевые Префиксы
При нейминге булевых переменных должен использоваться PascalCase, но с префиксом в виде глагола.

Пример: Используйте `isDead` и `hasItem`, а не `Dead` и `Item`.

###### Имена Булевых Переменных
Все переменные типа Boolean следует называть так, чтобы они описывали свои действия.

Старайтесь не использовать глаголы типа `isRunning`. Глаголы должны приводить к конечным состояниям.

###### Boolean Complex States
Не используйте булевые переменные для описания сложных/зависимых состояний. Это делает его трудным для чтения и сложнее при добавлении и. Используйте вместо них enumeration.

Пример: При определении состояния оружия **не** используйте `isReloading` и `isEquipping` если оружие не может быть перезаряжено и экипировано одновременно.
Определите его с помощью enumeration, как `WeaponState` и вместо этого - используйте переменную этого типа с именем `WeaponState`. Используя такой подход добавить новое состояние для оружия будет проще.

##### Enums
Для енумерации используйте PascalCase а также имена в единственном числе для enums и их значений.
Исключение: поле для bit enums должно быть во множественном числе.
Enums могут быть размещены вне пространства класса, для глобального доступа к ним.

Пример:	

```
public enum WeaponType
{
    Knife,
    Gun
}

// Enum могут иметь несколько значений
[Flags]
public enum Dockings
{
	None = 0,
	Top = 1,
}

public WeaponType Weapon
```

##### Массивы
Нейминг массивов следует правилу, описанному выше – однако он должен называться во множественном числе.

Пример: Используй `Targets`, `Hats`, и `EnemyPlayers`, а не `TargetList`, `HatArray`, `EnemyPlayerArray`.

##### Интерфейсы
Интерфейсы начинаются с заглавной `“I“` всё остальное - PascalCase.

Пример:

```public interface ICanEat { }```

<a name="functions"></a>
### 3.4 Функции, События, and Диспетчеры Событий
В этом разделе описывается, как следует создавать функции, события и диспетчеры событий. Всё, что применимо к функциям, применимо и к событиям, если не указано иное.

#### Нейминг Функций
Именование функций, событий и диспетчеров событий имеет большое значение. Только на основании названия можно понять, за что отвечает.

Например:
* Это чистая функция?
* Это получение информации о состоянии?
* Это обработчик?
* Какова цель?

На все подобные вопросы можно ответить, если функция корректно названа.

<a name="function-verbrule"></a>
#### Название Всех Функций Должно Содержать Глагол 
Все функции и события совершают какие-либо действия, например: получение информации, вычисления, либо событие или функция заставляет что-то взорваться. Поэтому все функции и события должны содержать глагол. 

По возможности глагол должен писаться в настоящем времени.

Они также должны иметь название, соответствующее их действиям.

Примеры хорошего нейминга:

* `Fire` - Хороший пример в классе персонажа/оружия, поскольку у него есть контекст. Плохо, если в Бочке/Траве/любом подобном неоднозначном классе.
* `Jump` - Хороший пример в классе персонажа, однако плохо в другом, не столь однозначном классе.
* `Explode`
* `ReceiveMessage`
* `SortPlayerArray`
* `GetArmOffset`
* `GetCoordinates`
* `UpdateTransforms`
* `EnableBigHeadMode`
* `IsEnemy` - ["Is" это глагол.](http://writingexplained.org/is-is-a-verb)

Примеры плохого нейминга:

* `Dead` - Это уже мёртво? Будет умерщвлено?
* `Rock`
* `ProcessData` - Двусмысленное, мало значащее название.
* `PlayerState` - Неоднозначное название, только существительные.
* `Color` - Неоднозначно, может это глагол (покрасить) или существительное (цвет).

#### Функции Возвращающие Bool Должны Быть Вопросительными
Когда вы создаёте функцию, которая не изменяет состояние или какой-либо объект, если она создана для получения информации, состояния, или вычисления значения да/нет, её название должно быть вопросительным. Она также следует [правилу глагола](#function-verbrule).

Это очень важно, потому как, если она не будет вопросительной, можно подумать, что она выполняет действие, результатом которого будет ответ.

Хорошие примеры:

* `IsDead`
* `IsOnFire`
* `IsAlive`
* `IsSpeaking`
* `IsHavingAnExistentialCrisis`
* `IsVisible`
* `HasWeapon` - ["Has" это глагол.](http://grammar.yourdictionary.com/parts-of-speech/verbs/Helping-Verbs.html)
* `WasCharging` - ["Was" это "заряжался" в прошедшем времени.](http://grammar.yourdictionary.com/parts-of-speech/verbs/Helping-Verbs.html) Используйте "was", если относите к 'предыдущему кадру' или 'предыдущему состоянию'.
* `CanReload` - ["Can" это глагол.](http://grammar.yourdictionary.com/parts-of-speech/verbs/Helping-Verbs.html)

Плохие примеры:

* `Fire` - Оно горит? Будет гореть? Разжигает огонь?
* `OnFire` - Можно спутать с диспетчером событий для стрельбы.
* `Dead` - Это уже мёртво? Будет умерщвлено?
* `Visibility` - Оно видимо? Изменение видимости? Описание условий полета?

#### Обработчики событий и диспетчеры Должны начинаться с `On`
Название любой функции, которая обрабатывает или отправляет событие, должна начинаться с `“On”` и продолжать следовать [правилу глагола](#function-verbrule).

Хорошие примеры:

* `OnDeath` - Распространённое словосочетание в играх
* `OnPickup`
* `OnReceiveMessage`
* `OnMessageRecieved`
* `OnTargetChanged`
* `OnClick`
* `OnLeave`

Плохие примеры:

* `OnData`
* `OnTarget`

**[⬆ Вверх](#table-of-contents)**
<a name="anc"></a>
<a name="4"></a>

## 4. Правила Нейминга Ассетов и Назначение Лейблов
Правила нейминга должны трактоваться как закон. В проекте, в котором действуют правила нейминга, ассеты с лёгкостью можно найти и управлять ими.

Большинство ассетов имеют префикс, обычно представляющий собой аббревиатуру соответствующего файлу типа, за которой следует подчеркивание.

**Найминг Ассетов с [PascalCase](#cases)**

<a name="base-asset-name"></a>
<a name="4.1"></a>
### 4.1 Шаблон Нейминга Ассета - `Prefix_BaseAssetName_Variant_Suffix`
Все ассеты должны иметь *Базовое* Имя. Базовое имя показывает к какой логической группе относится ассет. Любой ассет, являющийся частью логической группы должен именоваться по шаблону `Prefix_BaseAssetName_Variant_Suffix`.

Использование паттерна `Prefix_BaseAssetName_Variant_Suffix` и здравого смысла обычно хватает для написания хороших названий ассетов.
Вот несколько подробных правил относительно каждого элемента: `Prefix` и `Suffix` определяются типом ассета, следуя таблице [Asset Name Modifier](#asset-name-modifiers).

`BaseAssetName` должно быть сокращённым и понятным именем в зависимости от типа ассета, относящее его к соответствующей группе. К примеру, если у вас есть персонаж с именем Боб, все ассеты связанные с Бобом, будут иметь `BaseAssetName` как `Bob`.

Для уникальных и особых вариаций ассетов, `Variant` – это короткое и узнаваемое название, отражающее логическую группу ассета и относящее к основному ассету. К примеру, если у Боба много одежды, эта одежда должна использовать `Bob` как `BaseAssetName`, но и включать узнаваемое `Variant`. Как 'Злобную' одежду, можно назвать `Bob_Evil` так и 'Ретро' одежду можно назвать `Bob_Retro`.

Для уникальных, но общих вариаций ассетов, `Variant` это две цифры `01`. Например, если ваш художник по окружению сгенерировал камни, предположим, одного размера, они должны называться `Rock_01`, `Rock_02`, `Rock_03` и тд. Никогда не следует использовать трёхзначный номер вариации за редким исключением. Если у вас более 100 вариаций ассета, вам следует рассмотреть возможность организации их с разными базовыми именами или использованием нескольких вариантов имен.

В зависимости от того, каким образом были сделаны ваши ассеты, вы можете объединить их имена. Например, вы создали ассеты пола для Arch Viz project, значит вы называете их `Flooring` с соответствующими вариантами: `Flooring_Marble_01`, `Flooring_Maple_01`, `Flooring_Tile_Squares_01`.


<a name="1.1-examples"></a>
#### Примеры

##### Персонажи

| Тип Ассета               | Название Ассета   |
| ------------------------ | ------------ |
| Skeletal Mesh            | SK_Bob       |
| Material                 | M_Bob        |
| Texture (Diffuse/Albedo) | T_Bob_D      |
| Texture (Normal)         | T_Bob_N      |
| Texture (Evil Diffuse)   | T_Bob_Evil_D |

##### Объекты окружения

| Тип Ассета               | Название Ассета   |
| ------------------------ | ------------ |
| Static Mesh (01)         | SM_Rock_01   |
| Static Mesh (02)         | SM_Rock_02   |
| Static Mesh (03)         | SM_Rock_03   |
| Material                 | M_Rock       |
| Material Instance (Snow) | MI_Rock_Snow |

<a name="asset-name-modifiers"></a>
### 4.2 Asset Name Modifiers

При нейминге ассета, используйте таблицы для определения префикса и суффикса для использования совместно с [Base Asset Name](#base-asset-name).

#### Sections

> 4.2.1 [Most Common](#anc-common)

> 4.2.2 [Animations](#anc-animations)

> 4.2.3 [Artificial Intelligence](#anc-ai)

> 4.2.4 [Prefabs](#anc-prefab)

> 4.2.5 [Materials](#anc-materials)

> 4.2.6 [Textures](#anc-textures)

> 4.2.7 [Miscellaneous](#anc-misc)

> 4.2.8 [Physics](#anc-physics)

> 4.2.9 [Audio](#anc-audio)

> 4.2.10 [User Interface](#anc-ui)

> 4.2.11 [Effects](#anc-effects)

<a name="anc-common"></a>
#### Most Common

| Тип Ассета              | Префикс     | Суффикс     | Примечание                            |
| ----------------------- | ---------- | ---------- | -------------------------------- |
| Level / Scene           |  *          |            | [Должно располагаться в папке «Уровни».](#levels) e.g. `Levels/A4_C17_Parking_Garage.unity` |
| Level (Persistent)      |            | _P         |                                  |
| Level (Audio)           |            | _Audio     |                                  |
| Level (Lighting)        |            | _Lighting  |                                  |
| Level (Geometry)        |            | _Geo       |                                  |
| Level (Gameplay)        |            | _Gameplay  |                                  |
| Prefab                  |        |            |                                  |
| Material                | M_         |            |                                  |
| Static Mesh             | SM_       |            |                                  |
| Skeletal Mesh           | SK_       |            |                                  |
| Texture                 | T_         | _?         | Смотрите [Textures](#anc-textures)    |
| Particle System         | PS_       |            |                                  |

<a name="anc-models"></a>

#### 4.2.1a 3D Models (FBX Files)

PascalCase

| Тип Ассета    | Префикс | Суффикс | Примечание |
| ------------- | ------ | ------ | ----- |
| Characters    | CH_    |        |       |
| Vehicles      | VH_    |        |       |
| Weapons       | WP_    |        |       |
| Static Mesh   | SM_    |        |       |
| Skeletal Mesh | SK_    |        |       |
| Skeleton      | SKEL_  |        |       |
| Rig           | RIG_   |        |       |

#### 4.2.1b 3d Models (Other)

Названия всех мешей пишутся прописными, чтобы отличить от экспортных FBX.

| Тип Ассета    | Префикс | Суффикс      | Примечание                                   |
| ------------- | ------ | ----------- | --------------------------------------- |
| Mesh Collider |        | _collider   |                                         |

<a name="anc-animations"></a>

#### 4.2.2 Animations 
| Тип Ассета           | Префикс | Суффикс | Примечание |
| -------------------- | ------ | ------ | ----- |
| Animation Clip       | A_     |        |       |
| Animation Controller | AC_    |        |       |
| Avatar Mask          | AM_    |        |       |
| Morph Target         | MT_    |        |       |

<a name="anc-ai"></a>
#### 4.2.3 Artificial Intelligence

| Тип Ассета              | Префикс     | Суффикс     | Примечание                            |
| ----------------------- | ---------- | ---------- | -------------------------------- |
| AI Controller           | AIC_     |            |                                  |
| Behavior Tree           | BT_      |            |                                  |
| Blackboard              | BB_       |            |                                  |
| Decorator               | BTDecorator_ |          |                                  |
| Service                 | BTService_ |            |                                  |
| Task                    | BTTask_  |            |                                  |
| Environment Query       | EQS_     |            |                                  |
| EnvQueryContext         | EQS_     | Context    |                                  |

<a name="anc-prefab"></a>
#### 4.2.4 Prefabs

| Тип Ассета              | Префикс     | Суффикс     | Примечание                            |
| ----------------------- | ---------- | ---------- | -------------------------------- |
| Prefab         |        |            |                                  |
| Prefab Instance         | I       |            |                                  |
| Scriptable Object       |     |        | Назначить "Blueprint" лейбл в Editor |

<a name="anc-materials"></a>

#### 4.2.5 Materials
| Тип Ассета        | Префикс | Суффикс | Примечание |
| ----------------- | ------ | ------ | ----- |
| Material          | M_     |        |       |
| Material Instance | MI_    |        |       |
| Physical Material | PM_    |        |       |

<a name="anc-textures"></a>

#### 4.2.6 Textures
| Тип Ассета              | Префикс     | Суффикс     | Примечание                            |
| ----------------------- | ---------- | ---------- | -------------------------------- |
| Texture                 | T_         |            |                                  |
| Texture (Diffuse/Albedo/Base Color)| T_ | _D      |                                  |
| Texture (Normal)        | T_         | _N         |                                  |
| Texture (Roughness)     | T_         | _R         |                                  |
| Texture (Alpha/Opacity) | T_         | _A         |                                  |
| Texture (Ambient Occlusion) | T_     | _AO      |                                  |
| Texture (Bump)          | T_         | _B         |                                  |
| Texture (Emissive)      | T_         | _E         |                                  |
| Texture (Mask)          | T_         | _M         |                                  |
| Texture (Specular)      | T_         | _S         |                                  |
| Texture (Packed)        | T_         | _*         | Подробнее об этом ниже - [Упаковка Текстур](#anc-textures-packing). |
| Texture Cube            | TC_       |            |                                  |
| Media Texture           | MT_       |            |                                  |
| Render Target           | RT_       |            |                                  |
| Cube Render Target      | RTC_     |            |                                  |
| Texture Light Profile   | TLP_     |            |                                  |

<a name="anc-textures-packing"></a>

#### 4.2.6.1 Упаковка Текстур
Упаковка нескольких текстур в одну многослойную – обычная практика. Например, этот пакет содержит: Emissive, Roughness, Ambient Occlusion вместе, как Red канал, Green канал, и Blue канал, для соответствующих текстур. Для создания суффикса для подобного ассета просто сложите из них аббревиатуру, по типу – `“_ERO“`.

Обычно допустимо включать слой Alpha/Opacity в альфа-канал Diffuse/Albedo, и поскольку это обычная практика, добавление A к суффиксу _D не является обязательным.

Упаковка 4-х каналов в одну (RGBA) текстуру не рекомендуется, если только не присутствует маска Alpha/Opacity в альфа-канале Diffuse/Albedo's поскольку текстура с альфа-каналом требует больше чем текстура без него. 

<a name="anc-misc"></a>

#### 4.2.7 Разнообразные Типы Ассетов

| Тип Ассета                      | Префикс | Суффикс | Примечание |
| ------------------------------- | ------ | ------ | ----- |
| Universal Render Pipeline Asset | URP_   |        |       |
| Post Process Volume Profile     | PP_    |        |       |
| User Interface                  | UI_    |        |       |

<a name="anc-physics"></a>
#### 4.2.8 Physics

| Тип Ассета        | Префикс | Суффикс | Примечание |
| ----------------- | ------ | ------ | ----- |
| Physical Material | PM_    |        |       |

<a name="anc-audio"></a>

#### 4.2.9 Audio

| Тип Ассета     | Префикс | Суффикс | Notes                                                        |
| -------------- | ------ | ------ | ------------------------------------------------------------ |
| Audio Clip     | A_     |        |                                                              |
| Audio Mixer    | MIX_   |        |                                                              |
| Dialogue Voice | DV_    |        |                                                              |
| Audio Class    |        |        | Не используется суффикс и префикс. Должно находится в папке "AudioClasses" |

<a name="anc-ui"></a>
#### 4.2.10 User Interface
| Тип Ассета       | Префикс | Суффикс | Примечание |
| ---------------- | ------ | ------ | ----- |
| Font             | Font_  |        |       |
| Texture (Sprite) | T_     | _GUI   |       |

<a name="anc-effects"></a>
#### 4.2.11 Effects
| Тип Ассета      | Префикс | Суффикс | Примечание |
| --------------- | ------ | ------ | ----- |
| Particle System | PS_    |        |       |

4.3 Лейблы
Поскольку у префабов нет суффикса и префикса, для их упрощённого поиска им назначаются лейблы, разделяющие префабы по группам, группы, к которым относятся соответствующие лейблы отображены в таблице ниже

| Назначение Объекта 	| Лейбл |
| ---------------- 	| ------ |
| Транспорт (воздушный, наземный, водный)             | Transport |
| Военный (постройка, предмет, персонаж, техника)             | Military |
| Композиция из префабов            | CP |
| Постройка (здание)             | Building |
| Объект окружения небольшого размера, исключающий прочие группы             | Environment |
| Объект, относящийся к земле (разметка, трещина и тп.), исключающий прочие группы           | GroundAsset |
| Большой объект, относящийся к индустриализации (строительный кран, уличный фонарь, контейнер, дороги, платформы), исключающий прочие группы            | Industrial |
| Объект природного происхождения (камень, дерево и тп.)             | Nature |
| Цельный префаб, собранный из префабов (башня из сегментов)             | Complete |
| Префаб шаблона (Расстановка домов с заборами)            | Template |

**[⬆ Вверх](#table-of-contents)**

<a name="asset-workflows"></a>

## 5. Asset Workflows

В этом разделе описаны лучшие практики создания и импорта ассетов для использования в Unity.

<a name="toc"></a>
### Sections

> 5.1 [Unity Asset Import Settings](#unityimport)
>
> 5.2 [Textures](#textures)
>
> 5.3 [Audio](#audio)

<a name="unityimport"></a>

### 5.1 Настройки Импорта В Unity

Unity's [AssetPostprocessor](https://docs.unity3d.com/ScriptReference/AssetPostprocessor.html) позволяет подключаться к конвейеру импорта и запускать скрипты во время или после импорта.

Это позволяет вам применять настройки импорта при первом импорте ассета в проект. Например, при импорте текстура с суффиксом “_N“, может быть помечена как Normal Map.

Гайд как пример по Import Settings:

https://github.com/justinwasilenko/Unity-AssetPostProcessor

<a name="textures"></a>
### 5.2 Текстуры

* Названия текстур должно следовать [Правилу Нейминга Ассетов](#anc-textures), расположенной выше. 
* Разрешение текстур – степень двойки (Например: 512 x 512 или 256 x 1024).
* Используйте атласы текстур где это возможно.
* При экспорте текстур из 3D программы установите настройки экспорта специально для Unity.
* Если известно конечное максимальное разрешение текстур в проекте лучше всего изменить разрешение текстур в Photoshop, а после использовать компрессию Unity. Это уменьшит размер импортируемой текстуры в Unity.
* Когда ведётся работа над PSD высокого разрешения, используйте одинаковые названия для файлов высокого разрешения и готовых для Unity. Такой подход позволяет быстро переключаться между обоими текстурами.


Подробнее про импорт текстур: [https://docs.unity3d.com/Manual/ImportingTextures.html](https://docs.unity3d.com/Manual/ImportingTextures.html)

Подробнее про текстуры, требующие (имеющие) альфа канал: [https://docs.unity3d.com/Manual/HOWTO-alphamaps.html](https://docs.unity3d.com/Manual/HOWTO-alphamaps.html)

##### Texture File Format

All textures should be of the .PSD format. No layers should be included and only one Alpha channel in the imported file.

**[⬆ Вверх](#table-of-contents)**

<a name="audio"></a>
### 5.4 Звук

При импорте в Unity используйте аудиофайлы без компрессии, такого формата как WAV или AIFF.

Подробнее: [Unity Audio Import Optimization](https://www.gamasutra.com/blogs/ZanderHulme/20190107/333794/Unity_Audio_Import_Optimisation__getting_more_BAM_for_your_RAM.php)

**[⬆ Вверх](#table-of-contents)**



#### Article References:
https://unity3d.com/learn/tutorials/topics/tips/large-project-organisation
https://github.com/Allar/ue4-style-guide
http://www.arreverie.com/blogs/unity3d-best-practices-folder-structure-source-control/
